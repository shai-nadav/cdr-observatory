using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Pipeline.Components.OSVParser.Config
{
    /// <summary>
    /// Loads and saves extension ranges from/to files.
    /// </summary>
    public static class ExtensionRangeLoader
    {
        /// <summary>
        /// Load extension ranges from file or config property.
        /// File takes precedence if ExtensionRangesFile is set.
        /// </summary>
        public static List<string> LoadRanges(CdrProcessorConfig config)
        {
            var ranges = new List<string>();
            
            // Load from external file if specified
            if (!string.IsNullOrEmpty(config.ExtensionRangesFile) && File.Exists(config.ExtensionRangesFile))
            {
                ranges.AddRange(LoadFromFile(config.ExtensionRangesFile));
            }
            
            // Also load from discovered extensions file if it exists
            if (!string.IsNullOrEmpty(config.DiscoveredExtensionsFile) && File.Exists(config.DiscoveredExtensionsFile))
            {
                ranges.AddRange(LoadFromFile(config.DiscoveredExtensionsFile));
            }
            
            // Fall back to inline config if no files loaded anything
            if (ranges.Count == 0 && config.ExtensionRanges != null)
            {
                ranges.AddRange(config.ExtensionRanges);
            }
            
            return ranges.Distinct().ToList();
        }

        /// <summary>
        /// Load ranges from a text file. Supports:
        /// - One range per line
        /// - Comma-separated ranges on same line
        /// - Comments starting with #
        /// - Empty lines (ignored)
        /// </summary>
        public static List<string> LoadFromFile(string filePath)
        {
            var ranges = new List<string>();
            foreach (var line in File.ReadLines(filePath))
            {
                var trimmed = line.Trim();
                if (string.IsNullOrEmpty(trimmed) || trimmed.StartsWith("#"))
                    continue;
                
                // Support comma-separated on same line
                foreach (var part in trimmed.Split(new[] { "," }, StringSplitOptions.RemoveEmptyEntries))
                {
                    var range = part.Trim();
                    if (!string.IsNullOrEmpty(range) && !range.StartsWith("#"))
                        ranges.Add(range);
                }
            }
            return ranges;
        }

        /// <summary>
        /// Save discovered extensions to a file.
        /// Appends new extensions that aren''t already in the file.
        /// </summary>
        public static void SaveDiscovered(string filePath, IEnumerable<string> extensions)
        {
            if (string.IsNullOrEmpty(filePath) || !extensions.Any())
                return;

            // Load existing to avoid duplicates
            var existing = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            if (File.Exists(filePath))
            {
                foreach (var ext in LoadFromFile(filePath))
                    existing.Add(ext);
            }

            // Find new extensions
            var newExtensions = extensions.Where(e => !existing.Contains(e)).ToList();
            if (newExtensions.Count == 0)
                return;

            // Append to file
            using (var writer = new StreamWriter(filePath, append: true))
            {
                // Add header comment if file is new
                if (!File.Exists(filePath) || new FileInfo(filePath).Length == 0)
                {
                    writer.WriteLine("# Auto-discovered extension ranges");
                    writer.WriteLine("# Generated by CDR Processor");
                    writer.WriteLine();
                }
                
                writer.WriteLine($"# Discovered {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
                foreach (var ext in newExtensions.OrderBy(e => e))
                {
                    writer.WriteLine(ext);
                }
            }
        }
    }
}

